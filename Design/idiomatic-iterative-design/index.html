<!DOCTYPE html>
<html lang="en" xml:lang="en">

  <head>
  
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>Idiomatic Iterative Design | Western Devs</title>
  <meta name="description" content="Lately I have been having fun solving the AdventOfCode. I mainly used Haskell to solve each day so I can learn a bit about Haskell and as a byproduct VIM as well. In the last Ruby Meetup we used Day 7">
<meta property="og:type" content="article">
<meta property="og:title" content="Idiomatic Iterative Design">
<meta property="og:url" content="https://westerndevs.com/Design/idiomatic-iterative-design/index.html">
<meta property="og:site_name" content="Western Devs">
<meta property="og:description" content="Lately I have been having fun solving the AdventOfCode. I mainly used Haskell to solve each day so I can learn a bit about Haskell and as a byproduct VIM as well. In the last Ruby Meetup we used Day 7">
<meta property="article:published_time" content="2016-03-23T20:00:00.000Z">
<meta property="article:modified_time" content="2022-11-01T12:58:25.089Z">
<meta property="article:author" content="Western Devs">
<meta property="article:tag" content="design">
<meta property="article:tag" content="ruby">
<meta property="article:tag" content="functional">
<meta name="twitter:card" content="summary">
<meta name="twitter:creator" content="@westerndevs">

    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="title" content="WesternDevs">   
    <meta name="keywords" content="software development,software,asp.net,blog">
    <meta name="description" content="We're all west of somewhere">
    <meta name="copyright" content="WesternDevs">
    <meta name="revisit-after" content="15 days">
    <meta name="robots" content="all">
    <meta name="MSSmartTagsPreventParsing" content="true">
  
    <link rel="canonical" href="http://orthocoders.com/blog/2016/02/16/idiomatic-iterative-design/">
  
  
    <link rel="alternate" href="/feed.xml" title="Western Devs" type="application/atom+xml">
  
  
<link rel="stylesheet" href="/css/style.css">

      
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <script src="//code.jquery.com/jquery-1.11.3.min.js"></script>  
  <meta name="generator" content="Hexo 4.2.1"></head>

<body>

<!-- FIXED HEADER BECAUSE SCROLLING -->
<!--HEADER STARTS-->
<div class="WrapperHeader">
<div style="display:inline-block; text-align: center;">
<div class="Header">

  <div class="HeaderLogo">
    <a href="/"><img src="/images/header_logo_transparent.png" alt="WesternDevs" title="WesternDevs" border="0" style="width: 206px; height: 64px;" width="206" height="64"></a>
  </div>

  <div class="HeaderLinks">
      <a href="/posts" class="nav">POSTS</a>       
      <a href="/podcasts" class="nav">PODCASTS</a>       
      <a href="/whoweare" class="nav">ABOUT</a>  
      <a href="/whatwevedone" class="nav">WHAT WE'VE DONE</a>  
      <a href="/speaking" class="nav">SPEAKING</a>
      <div class="HeaderIcons">
        <a href="mailto:info@westerndevs.com"><img src="/images/icon_email.png" border="0" alt="Email" title="Email" height="26" width="26"></a>
        <a href="/feed.xml"><img src="/images/icon_subscribe.png" border="0" alt="Subscribe" title="Subscribe" height="26" width="27"></a>
        <a href="http://twitter.com/westerndevs" target="_blank"><img src="/images/icon_twitter.png" border="0" alt="Twitter" title="Twitter" height="26" width="27"></a>
        <a href="http://github.com/westerndevs" target="_blank"><img src="/images/icon_github.png" border="0" alt="GitHub" title="GitHub" height="26" width="27"></a>     
      </div>
  </div>
  
</div>
</div>
</div>
<!--HEADER ENDS-->    



<!--WRAPPER STARTS-->
<div class="Wrapper" style="">

<!--SUBHEAD STARTS-->
<div class="WrapperSubHeaderSubpage">
<center>
	<div class="SubHeader">
		<H1 class="title"><img class="icon" src="/images/icon_posts.png" alt="POST" title="POST" border="0"> POST</H1>
	</div>
</center>
</div>
<!--SUBHEAD ENDS-->

<!--PAGE CONTENT STARTS-->
<center>
<div class="WrapperContent">

<!--MAIN CONTENT STARTS-->
	<div class="SubpageBoxSubLrg">
		<div class="SubpageBoxSubLrgContent">
		    <div class='postTitle'>
  <div class="ListLrgDateBG">
    <div class="ListLrgDateMonth">MAR</div>
    <div class="ListLrgDateDay">23</div>
    <div class="ListLrgDateYear">2016</div>
  </div>
  <h2>Idiomatic Iterative Design</h2>
</div>

		    

<p class="TXTsm">ORIGINALLY POSTED TO: <a href="http://orthocoders.com/blog/2016/02/16/idiomatic-iterative-design/" target="_blank" rel="noopener" class='originalurl'>http://orthocoders.com/blog/2016/02/16/idiomatic-iterative-design/</a></p>



			<div id="mainPostContent">
	        <p>Lately I have been having fun solving the <a href="http://adventofcode.com" target="_blank" rel="noopener">AdventOfCode</a>. I mainly used <em>Haskell</em> to solve each day so I can learn a bit about <em>Haskell</em> and as a byproduct <em>VIM</em> as well.</p>
<p>In the last <a href="http://winnipegrb.org" target="_blank" rel="noopener">Ruby Meetup</a> we used <a href="http://adventofcode.com/day/7" target="_blank" rel="noopener">Day 7</a> to illustrate how to use <a href="https://github.com/abargnesi/rantly" target="_blank" rel="noopener">Rantly</a> for properties testing.</p>
<p>It was my first try to solve <em>Day 7</em> using <a href="https://github.com/amirci/adventofcode_rb" target="_blank" rel="noopener">Ruby</a>, and I wanted to find an <em>elegant</em>, <em>idiomatic</em>, <em>short</em> way to do it...</p>
<a id="more"></a>
<h2>Before we start</h2>
<p>First I want to give a very big shout out to <a href="http://was.tl/" target="_blank" rel="noopener">Eric Wastl</a> for creating the <a href="http://adventofcode.com/" target="_blank" rel="noopener">Advent Of Code</a>.</p>
<p>Try it out, and if you like it let <a href="https://twitter.com/ericwastl" target="_blank" rel="noopener">Eric</a> know!</p>
<h2>Exploring the problem</h2>
<p>SPOILER ALERT: Yes, we are going to talk about <em>Day 7</em> and how to implement the solution. Feel free to do it on your own first.</p>
<p>The problem describes a circuit board with instructions to apply signals to circuits using bitwise logic operations.</p>
<p>The operations are:</p>
<pre><code>- 123 -&gt; x means that the signal 123 is provided to wire x.
- x AND y -&gt; z means that the bitwise AND of wire x and wire y 
  is provided to wire z.
- p LSHIFT 2 -&gt; q means that the value from wire p is left-shifted by 2 
  and then provided to wire q.
- NOT e -&gt; f means that the bitwise complement of the value from 
  wire e is provided to wire f.

Other possible gates include OR (bitwise OR) and RSHIFT (right-shift).
</code></pre>
<p>I implemented the solution in <a href="https://github.com/amirci/adventofcode_hs" target="_blank" rel="noopener">Haskell</a> and found out that not only the parsing was the challenge but also the fact that you get a list of instructions that can be in any order, so some instructions when evaluated may result in having no signal (no value).</p>
<p>For example, let's consider the following sequence of instructions:</p>
<pre><code>lx -&gt; a
456 -&gt; lx
</code></pre>
<p>When evaluating the first instruction, the wire <code>lx</code> has no signal yet, so it has to be reevaluated later.</p>
<p>Of course you could create an evaluation tree but that seemed a bit too much for the problem at hand. So I decided to do the following:</p>
<ol>
<li>Parse instructions into commands</li>
<li>Repeat evaluating commands until all pass</li>
<li>Return the value of wire &quot;a&quot; from the board</li>
</ol>
<h2>The <em>classy</em> way</h2>
<p>As soon as I read about <em>instructions</em> my mind started to race thinking about <em>parsing</em> and <em>patterns</em>.</p>
<p>My first thought was I could use the <a href="https://en.wikipedia.org/wiki/Interpreter_pattern" target="_blank" rel="noopener">Interpreter Pattern</a> to build a hierarchy of classes to evaluate expressions. But it seemed like an overkill.</p>
<p>Therefore, I decided to use classes to represent each command:</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AndCmd</span>    ;</span> <span class="keyword">end</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrCmd</span>     ;</span> <span class="keyword">end</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LShiftCmd</span> ;</span> <span class="keyword">end</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RShiftCmd</span> ;</span> <span class="keyword">end</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NotCmd</span>    ;</span> <span class="keyword">end</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EvalCmd</span>   ;</span> <span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>Each <em>class</em> has two methods with clear responsibilities:</p>
<ul>
<li>
<p><code>parse(token1, token2, token3..., wire)</code> Class factory method that parses the command and returns an instance of the command.</p>
</li>
<li>
<p><code>wireIt(board)</code> Instance method that evaluates the command to assign the result of the operation to the target wire.</p>
</li>
</ul>
<p>The constructor of the class stores the operands and target wire.</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AndCmd</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(lhs, rhs, wire)</span></span> ; @lhs, @rhs, @wire = [lhs, rhs, wire] <span class="keyword">end</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">wireIt</span><span class="params">(board)</span></span> </span><br><span class="line">    <span class="comment"># asign the <span class="doctag">@lhs</span> &amp; <span class="doctag">@rhs</span> to the board</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">self</span>.<span class="title">parse</span><span class="params">(....)</span></span></span><br><span class="line">    <span class="comment"># parse the string to match the AND command and return a new instance</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>The <code>parse</code> factory method receives the expected tokens. If the <code>cmd</code> token matches the string <code>&quot;AND&quot;</code> then returns an instance of <code>AndCmd</code>.</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">self</span>.<span class="title">parse</span><span class="params">(x, cmd, y, arrow, z)</span></span></span><br><span class="line">  AndCmd.new(x, y, z) <span class="keyword">if</span> cmd == <span class="string">"AND"</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h3>Abstracting the board</h3>
<p>Evaluating the command was more complex because the values could be undefined. Some kind of validation was necessary.</p>
<p>I started using a <code>Hash</code> as a <em>CircuitBoard</em> and then checking if the values were defined. It got a bit more complicated when I realized I had to parse values, because I could get <code>lx AND lb</code> and also <code>1 AND ll</code>.</p>
<p>Inspired by my <em>Haskell</em> solution I thought that a class that implements a <em>short circuit</em> evaluation could be very useful. That way, if one of the involved values was not defined the whole command was undefined.</p>
<p>To simplify board access and evaluation I created a <code>Board</code> class that handles the assignment plus the lookup.</p>
<p>The <code>assign</code> method takes a block that gets evaluated if all the values are defined, otherwise it is ignored.</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Board</span></span></span><br><span class="line">  <span class="keyword">attr_reader</span> <span class="symbol">:wires</span>                                           </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span> ;</span> @wires = &#123;&#125; <span class="keyword">end</span>                             </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">[]</span><span class="params">(y)</span></span> ; @wires[y] <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">assign</span><span class="params">(wire, *exprs)</span></span>                                     </span><br><span class="line">    values = exprs.map &#123; <span class="params">|exp|</span> value exp &#125;                     </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span> <span class="keyword">if</span> values.any?(&amp;<span class="symbol">:nil?</span>)·                         </span><br><span class="line">    @wires[wire] = block_given? ? <span class="keyword">yield</span>(*values) : values[<span class="number">0</span>]   </span><br><span class="line">  <span class="keyword">end</span>                                                          </span><br><span class="line"></span><br><span class="line">  private·                                                     </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">value</span><span class="params">(exp)</span></span>                                               </span><br><span class="line">    /\d+<span class="regexp">/.match(exp) ? exp.to_i : @wires[exp]                  </span></span><br><span class="line"><span class="regexp">  end                                                          </span></span><br><span class="line"><span class="regexp">end</span></span><br></pre></td></tr></table></figure>
<p>This simplifies things quite a bit. Now the <code>wireIt</code> implementation only applies the operation when all the values are defined:</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wireIt</span><span class="params">(board)</span></span></span><br><span class="line">  board.assign(@wire, @lhs, @rhs) &#123; <span class="params">|l, r|</span> l &amp; r &#125;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h3>Parsing instructions into commands</h3>
<p>To parse the string I created a <code>parse</code> method that splits the instruction into tokens (words) and finds a parsing factory method with the same amount of parameters that returns an actual instance of the command.</p>
<p>This is similar to a <a href="https://en.wikipedia.org/wiki/Chain-of-responsibility_pattern" target="_blank" rel="noopener">chain of responsibility</a> where the parser tries to parse the instruction. If the parser cannot do it then the parser passes the instruction to the next parser in the chain until one of them succeeds.  If no parser succeeds, <code>nil</code> is returned.</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(instruction)</span></span>                                              </span><br><span class="line">  tokens = instruction.split                                        </span><br><span class="line">  [AssignCmd, AndCmd, OrCmd, RightShiftCmd, LeftShiftCmd, NotCmd]   </span><br><span class="line">    .map    &#123; <span class="params">|k|</span> k.method(<span class="symbol">:parse</span>) &#125;                                </span><br><span class="line">    .select &#123; <span class="params">|m|</span> m.parameters.length == tokens.length &#125;            </span><br><span class="line">    .map    &#123; <span class="params">|m|</span> m.call(*tokens) &#125;                                 </span><br><span class="line">    .find   &#123; <span class="params">|cmd|</span> cmd &#125;·                                          </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h3>The main loop</h3>
<p>The last bit of the exercise is to keep evaluating all commands until there are no failing commands left.</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wire</span><span class="params">(instructions)</span></span>                                  </span><br><span class="line">  cmds = instructions.map(&amp;method(<span class="symbol">:parse</span>))              </span><br><span class="line">  board = Board.new                                     </span><br><span class="line">  <span class="keyword">while</span> !cmds.empty?                                    </span><br><span class="line">    cmds = cmds.select &#123; <span class="params">|cmd|</span> cmd.wireIt(board).<span class="literal">nil</span>? &#125; </span><br><span class="line">  <span class="keyword">end</span>                                                   </span><br><span class="line">  board                                                 </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>You can see the complete source <a href="https://github.com/amirci/adventofcode_rb/blob/master/lib/day7_v2.rb" target="_blank" rel="noopener">here</a>.</p>
<h2>The <em>Ruby</em> way</h2>
<p>After finishing the implementation using classes I started to wonder what would be more idiomatic to <em>Ruby</em>.</p>
<p>Classes are fine, but I wanted to explore the <em>dynamic</em> aspect of <em>Ruby</em> and use <code>eval</code>.</p>
<h3>Parsing instructions</h3>
<p>Instead of having a <code>Class</code> factory method to parse, I declared <code>parse_xxx</code> functions that return a string to be evaluated later for the expected command.</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">board</span><span class="params">(exp)</span></span> ; <span class="string">"board['<span class="subst">#&#123;exp&#125;</span>']"</span> <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">expr</span><span class="params">(exp)</span></span> ; <span class="regexp">/\d+/</span>.match(exp) ? exp : board(exp) <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_and</span><span class="params">(x, cmd, y, arrow, z)</span></span> </span><br><span class="line">  cmd == <span class="string">"AND"</span> &amp;&amp; <span class="string">"<span class="subst">#&#123;board z&#125;</span> = <span class="subst">#&#123;expr x&#125;</span> &amp; <span class="subst">#&#123;board y&#125;</span>"</span> </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>The main <code>parse</code> function now uses the <code>parse_xxx</code> functions instead. The parse chooses the function that has the same amount of parameters as the tokens in the instructions and also returns a string with the expression to be evaluated.</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(instruction)</span></span></span><br><span class="line">  tokens = instruction.split</span><br><span class="line">  [<span class="symbol">:parse_assign</span>, <span class="symbol">:parse_and</span>, <span class="symbol">:parse_or</span>, <span class="symbol">:parse_rshift</span>, <span class="symbol">:parse_lshift</span>, <span class="symbol">:parse_not</span>]</span><br><span class="line">  .map    &#123; <span class="params">|s|</span> method(s) &#125;</span><br><span class="line">  .select &#123; <span class="params">|m|</span> m.parameters.length == tokens.length &#125;                           </span><br><span class="line">  .map    &#123; <span class="params">|m|</span> m.call(*tokens) &#125;</span><br><span class="line">  .find   &#123; <span class="params">|cmd|</span> cmd &#125;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h3>The main loop</h3>
<p>The main loop is very similar to the main loop of the <em>classy version</em> with the difference that to get the actual value, <code>eval</code> is called for every command. If the command succeeds, the evaluation will return some kind of number.</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wire</span><span class="params">(instructions)</span></span>                                                     </span><br><span class="line">  cmds = instructions.map &#123; <span class="params">|line|</span> <span class="keyword">self</span>.parse line &#125;                       </span><br><span class="line">  board = &#123;&#125;                                                               </span><br><span class="line">  <span class="keyword">while</span> !cmds.empty?·                                                      </span><br><span class="line">    cmds = cmds.reject &#123; <span class="params">|cmd|</span> (eval(cmd) <span class="keyword">rescue</span> <span class="literal">nil</span>).kind_of? Fixnum &#125;    </span><br><span class="line">  <span class="keyword">end</span>                                                                      </span><br><span class="line">  board                                                                    </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h3>The result</h3>
<p>The solution seems simpler than using classes. The strings make each command quite transparent.</p>
<p>Probably, even the parsing could be combined into one function and reduce the amount of functions in general.</p>
<p>You can see the complete solution <a href="https://github.com/amirci/adventofcode_rb/blob/master/lib/day7_v3.rb" target="_blank" rel="noopener">here</a>.</p>
<h2>The <em>functional</em> way</h2>
<p>After the <em>Classy</em> and <em>Ruby</em> way I wanted to see if I could be a bit more functional.</p>
<p>The approach this time was to parse the instruction into a <code>lambda</code> that will evaluate the actual command.</p>
<p>I decided to reuse the <code>Board</code> class from the first solution to make the value evaluation easier and implement a short circuit when a value is not yet defined.</p>
<h3>Parsing instructions into commands</h3>
<p>Third time’s the charm! I reduced the amount of parsing functions by having a binary parsing function that uses a hash to decide which operation to apply.</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_bin</span><span class="params">(x, cmd, y, arrow, wire)</span></span>                                 </span><br><span class="line">  op = &#123;<span class="string">"AND"</span> =&gt; <span class="symbol">:&amp;</span>, <span class="string">"OR"</span> =&gt; <span class="symbol">:|</span>, <span class="string">"LSHIFT"</span> =&gt; <span class="symbol">:&lt;&lt;</span>, <span class="string">"RSHIFT"</span> =&gt; <span class="symbol">:&gt;&gt;</span>&#125;[cmd]</span><br><span class="line">  op &amp;&amp; -&gt; (board) &#123; board.assign(wire, x, y, &amp;op) &#125;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>The hash lookup  decides which operation to use.</p>
<p>The general <code>parse</code> function is similar to the <em>Ruby</em> way:</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(instruction)</span></span></span><br><span class="line"> tokens = instruction.split</span><br><span class="line"> [<span class="symbol">:parse_assign</span>, <span class="symbol">:parse_bin</span>, <span class="symbol">:parse_not</span>]</span><br><span class="line">   .map    &#123; <span class="params">|s|</span> method(s) &#125;</span><br><span class="line">   .select &#123; <span class="params">|m|</span> m.parameters.length == tokens.length &#125;</span><br><span class="line">   .map    &#123; <span class="params">|m|</span> m.call(*tokens) &#125;</span><br><span class="line">   .find   &#123; <span class="params">|cmd|</span> cmd &#125;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h3>The main loop</h3>
<p>Instead of using <code>eval</code>, the <code>call</code> method is used on each <code>lambda</code> to evaluate the command.</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wire</span><span class="params">(instructions)</span></span></span><br><span class="line">  cmds = instructions.map &#123; <span class="params">|line|</span> parse line &#125;</span><br><span class="line">  board = Board.new</span><br><span class="line">  <span class="keyword">while</span> !cmds.empty?</span><br><span class="line">    cmds = cmds.select &#123; <span class="params">|cmd|</span> cmd.call(board).<span class="literal">nil</span>? &#125;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  board</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>You can see the entire solution <a href="https://github.com/amirci/adventofcode_rb/blob/master/lib/day7_v4.rb" target="_blank" rel="noopener">here</a>.</p>
<h2>The verdict</h2>
<p>The version I like the most is the <code>eval</code> version because it is simple and straightforward.</p>
<p>The second best option, in my opinion, is the <em>functional</em> version because it uses  the bitwise logic operators as functions.</p>
<p>Last but not least is the <em>classy</em> version. Using instances of classes does not seem to be necessary for this exercise because all parameters can be captured when creating the <code>lambda</code> closure for each instruction.</p>
<p>Which one is would <strong>you</strong> choose?</p>

	        </div>

            
            <section id="comments">
            <div id="disqus_thread">
                <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript" target="_blank" rel="noopener">comments powered by Disqus.</a></noscript>
            </div>
            </section>
            
		</div>
	</div>
<!--MAIN CONTENT ENDS-->

<!--SIDEBAR CONTENT STARTS-->
	<div class="SubpageBoxSubSm">
		<div class="SubpageBoxSubSmContent">
			
			

			<div class="ProfileImg">
				
				<a href="/bios/amir_barylko">
				
					<img src='https://www.gravatar.com/avatar/fadb1de2c18ab0fc42ebc0988327c90f?s=200' />
				
				</a>
				
			</div>

			<BR clear="all">

			<h2><a href="/bios/amir_barylko">Amir Barylko</a></h2>
			
			<a href="mailto:amir@barylko.com"><img class="ProfileIcon" src="/images/icon_email.png" border="0" alt="Email" title="Email"> Email</a><BR>
			
			
			<a href="http://www.orthocoders.com/" target="_blank"><img class="ProfileIcon" src="/images/icon_web.png" border="0" alt="Web" title="Web"> Web</a><BR>
			
			
			<a href="http://twitter.com/abarylko" target="_blank"><img class="ProfileIcon" src="/images/icon_twitter.png" border="0" alt="Twitter" title="Twitter"> Twitter</a><BR>
			
			
			<a href="https://github.com/amirci" target="_blank"><img class="ProfileIcon" src="/images/icon_github.png" border="0" alt="GitHub" title="GitHub"> GitHub</a><br>
			
			
			<a href="https://www.linkedin.com/in/amirbarylko" target="_blank"><img class="ProfileIcon" src="/images/icon_linkedin.png" border="0" alt="LinkedIN" title="LinkedIN"> LinkedIn</a><br>
			
			
 			<a href="/feeds/amir_barylko.xml"><img class="ProfileIcon" src="/images/icon_subscribe.png" /> RSS</a>
			

			<hr />
			<h4>Looking for someone else?</h4>
			<p>You can find the rest of the Western Devs Crew <a href="/whoweare">here</a>.</p>
		</div>
	</div>
<!--SIDEBAR CONTENT ENDS-->


</div>
</center>
<!--PAGE CONTENT ENDS-->


<!--FOOTER STARTS-->
<center>
  <div class="FooterBarTxt">&copy; 2015 Western Devs. All Rights Reserved. Design by <a href="http://www.karenchudobiak.ca" target="_blank">Karen Chudobiak, Graphic Designer</a></div>
</center>
<!--FOOTER ENDS-->

<!-- NAV FOOTER STARTS -->
<div class="NavFooter">
  <a href="/posts" alt="Posts"><i class="fa fa-newspaper-o fa-2x"></i><span>Posts</span></a>
  <a href="/podcasts" alt="Podcasts"><i class="fa fa-volume-up fa-2x"></i><span>Podcasts</span></a>
  <a href="/whoweare" alt="About"><i class="fa fa-star fa-2x"></i><span>About</span></a>
  <a href="/whatwevedone" alt="What We've Done"><i class="fa fa-trophy fa-2x"></i><span>Work</span></a>
  <a href="/speaking" alt="Speaking"><i class="fa fa-comment-o fa-2x fa-flip-horizontal"></i><span>Speaking</span></a>
</div>
<!-- NAV FOOTER ENDS -->




</div>
<!--WRAPPER ENDS-->


<script>
  var disqus_shortname = 'westerndevs';
  
  var disqus_url = 'https://westerndevs.com/Design/idiomatic-iterative-design/'.replace(".com//", ".com/");
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
  
function shuffle(array) {
  var currentIndex = array.length, temporaryValue, randomIndex;

  // While there remain elements to shuffle...
  while (0 !== currentIndex) {

    // Pick a remaining element...
    randomIndex = Math.floor(Math.random() * currentIndex);
    currentIndex -= 1;

    // And swap it with the current element.
    temporaryValue = array[currentIndex];
    array[currentIndex] = array[randomIndex];
    array[randomIndex] = temporaryValue;
  }

  return array;
}

</script>


</body>

  
<!-- Google Analytics -->
<script type="text/javascript">
if (document.location.hostname.search("westerndevs.com") !== -1 || document.location.hostname.search("www.westerndevs.com") !== -1) {
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-37617956-2', 'auto');

ga('set', 'contentGroup1', 'amir_barylko');

ga('send', 'pageview');
}
</script>
<!-- End Google Analytics -->



</html>
